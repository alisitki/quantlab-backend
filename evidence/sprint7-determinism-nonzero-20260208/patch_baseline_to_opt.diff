diff --git a/core/edge/discovery/PatternScanner.js b/core/edge/discovery/PatternScanner.js
index a4d1a9d..dc4c077 100644
--- a/core/edge/discovery/PatternScanner.js
+++ b/core/edge/discovery/PatternScanner.js
@@ -52,6 +52,10 @@ export class PatternScanner {
    * Exact semantics guaranteed: same input â†’ same output.
    */
   scan(dataset) {
+    const diagTiming = process.env.QUANTLAB_DIAG_TIMING === 'true';
+    this._diagTimingEnabled = diagTiming;
+    this._diagScanStart = diagTiming ? Date.now() : 0;
+
     console.log(`[PatternScanner] Scanning with methods: ${this.scanMethods.join(', ')}`);
 
     // Detect streaming vs array mode
@@ -60,13 +64,47 @@ export class PatternScanner {
 
     if (isStreaming) {
       console.log('[PatternScanner] Mode: STREAMING (async iterator detected)');
-      return this.#scanStreaming(dataset);
+      const p = this.#scanStreaming(dataset);
+      if (!diagTiming) return p;
+      return Promise.resolve(p).finally(() => {
+        this._diagTimingEnabled = false;
+        this._diagScanStart = 0;
+      });
     } else {
       console.log('[PatternScanner] Mode: ARRAY (backward compatible)');
-      return this.#scanArray(dataset);
+      try {
+        return this.#scanArray(dataset);
+      } finally {
+        this._diagTimingEnabled = false;
+        this._diagScanStart = 0;
+      }
     }
   }
 
+  #logMethodTiming(method, checkpoint, patterns, dataset) {
+    if (!this._diagTimingEnabled) return;
+
+    const scanStart = this._diagScanStart || 0;
+    let processedEvents = 'N/A';
+
+    if (dataset && dataset.rows && typeof dataset.rows.length === 'number') {
+      processedEvents = dataset.rows.length;
+    } else if (dataset && dataset.metadata && Number.isFinite(dataset.metadata.rowCount)) {
+      processedEvents = dataset.metadata.rowCount;
+    }
+
+    let line =
+      `[Timing][PatternScanner] method=${method} checkpoint=${checkpoint} ` +
+      `elapsed_ms_since_scan_start=${Date.now() - scanStart}`;
+
+    if (checkpoint === 'end') {
+      const candidatesSoFar = Array.isArray(patterns) ? patterns.length : 'N/A';
+      line += ` candidates_so_far=${candidatesSoFar} processed_events=${processedEvents}`;
+    }
+
+    console.log(line);
+  }
+
   /**
    * Check if object is async iterable
    */
@@ -81,15 +119,21 @@ export class PatternScanner {
     const patterns = [];
 
     if (this.scanMethods.includes('threshold')) {
+      this.#logMethodTiming('threshold', 'begin', patterns, dataset);
       patterns.push(...this.#scanThresholdPatterns(dataset));
+      this.#logMethodTiming('threshold', 'end', patterns, dataset);
     }
 
     if (this.scanMethods.includes('quantile')) {
+      this.#logMethodTiming('quantile', 'begin', patterns, dataset);
       patterns.push(...this.#scanQuantilePatterns(dataset));
+      this.#logMethodTiming('quantile', 'end', patterns, dataset);
     }
 
     if (this.scanMethods.includes('cluster')) {
+      this.#logMethodTiming('cluster', 'begin', patterns, dataset);
       patterns.push(...this.#scanClusterPatterns(dataset));
+      this.#logMethodTiming('cluster', 'end', patterns, dataset);
     }
 
     console.log(`[PatternScanner] Found ${patterns.length} total patterns`);
@@ -112,15 +156,21 @@ export class PatternScanner {
     const patterns = [];
 
     if (this.scanMethods.includes('threshold')) {
+      this.#logMethodTiming('threshold', 'begin', patterns, dataset);
       patterns.push(...await this.#scanThresholdPatternsStreaming(dataset));
+      this.#logMethodTiming('threshold', 'end', patterns, dataset);
     }
 
     if (this.scanMethods.includes('quantile')) {
+      this.#logMethodTiming('quantile', 'begin', patterns, dataset);
       patterns.push(...await this.#scanQuantilePatternsStreaming(dataset));
+      this.#logMethodTiming('quantile', 'end', patterns, dataset);
     }
 
     if (this.scanMethods.includes('cluster')) {
+      this.#logMethodTiming('cluster', 'begin', patterns, dataset);
       patterns.push(...await this.#scanClusterPatternsStreaming(dataset));
+      this.#logMethodTiming('cluster', 'end', patterns, dataset);
     }
 
     console.log(`[PatternScanner] Found ${patterns.length} total patterns (streaming)`);
@@ -145,8 +195,29 @@ export class PatternScanner {
     console.log('[PatternScanner] Running threshold scan...');
     const patterns = [];
 
+    const diagTiming = this._diagTimingEnabled === true;
+    const thStart = diagTiming ? Date.now() : 0;
+    const processedEvents = (dataset && dataset.rows && typeof dataset.rows.length === 'number')
+      ? dataset.rows.length
+      : (dataset && dataset.metadata && Number.isFinite(dataset.metadata.rowCount))
+        ? dataset.metadata.rowCount
+        : 'N/A';
+    const log = diagTiming
+      ? (checkpoint) => {
+        console.log(
+          `[Timing][Threshold] checkpoint=${checkpoint} ` +
+          `elapsed_ms_since_threshold_start=${Date.now() - thStart} ` +
+          `processed_events=${processedEvents} ` +
+          `candidates_so_far=${patterns.length}`
+        );
+      }
+      : () => {};
+
+    log('begin');
+
     // Early exit if no data
     if (dataset.rows.length === 0) {
+      log('end');
       return patterns;
     }
 
@@ -209,10 +280,15 @@ export class PatternScanner {
       }
     }
 
+    log('after_iterate');
+
     // Limit patterns
     const limited = patterns.slice(0, this.maxPatternsPerMethod);
     console.log(`[PatternScanner] Threshold scan found ${patterns.length} patterns (kept ${limited.length})`);
 
+    log('after_build');
+    log('end');
+
     return limited;
   }
 
@@ -452,6 +528,21 @@ export class PatternScanner {
   async #scanThresholdPatternsStreaming(dataset) {
     console.log('[PatternScanner] Running threshold scan (streaming)...');
 
+    const diagTiming = this._diagTimingEnabled === true;
+    const thStart = diagTiming ? Date.now() : 0;
+    const log = diagTiming
+      ? (checkpoint, processedEvents = 'N/A', candidatesSoFar = 'N/A') => {
+        console.log(
+          `[Timing][Threshold] checkpoint=${checkpoint} ` +
+          `elapsed_ms_since_threshold_start=${Date.now() - thStart} ` +
+          `processed_events=${processedEvents} ` +
+          `candidates_so_far=${candidatesSoFar}`
+        );
+      }
+      : () => {};
+
+    log('begin', 'N/A', 'N/A');
+
     // Prepare all threshold conditions upfront
     const conditions = [];
 
@@ -490,10 +581,18 @@ export class PatternScanner {
     for (const condition of conditions) {
       for (const horizon of horizonKeys) {
         for (const regime of regimesList) {
+          const horizonNum = parseInt(horizon.slice(1));
           testConfigs.push({
-            ...condition,
-            horizon: parseInt(horizon.slice(1)),
-            regime
+            featureName: condition.featureName,
+            operator: condition.operator,
+            value: condition.value,
+            horizon: horizonNum,
+            horizonKey: horizon,
+            regime,
+            // Precompute key strings to avoid per-row string interpolation.
+            configKey:
+              `${condition.featureName}_${condition.operator}_${condition.value}` +
+              `_r${regime}_h${horizonNum}`
           });
         }
       }
@@ -509,56 +608,47 @@ export class PatternScanner {
     let droppedConfigs = 0;
 
     for await (const row of dataset.rowsFactory()) {
-      for (const config of testConfigs) {
-        const configKey = `${config.featureName}_${config.operator}_${config.value}_r${config.regime}_h${config.horizon}`;
+      const rowRegime = row.regime;
+      const rowFeatures = row.features;
+      const rowForwardReturns = row.forwardReturns;
+
+      for (let i = 0; i < testConfigs.length; i++) {
+        const config = testConfigs[i];
+        const configKey = config.configKey;
 
         // Skip if config already exceeded max indices
-        const stats = configStats.get(configKey);
-        if (stats && stats.indices.length >= MAX_INDICES_PER_CONFIG) {
-          continue;
-        }
+        let stats = configStats.get(configKey);
+        if (stats && stats.indices.length >= MAX_INDICES_PER_CONFIG) continue;
 
         // Check regime constraint
-        if (config.regime !== null && row.regime !== config.regime) {
-          continue;
-        }
+        if (config.regime !== null && rowRegime !== config.regime) continue;
 
         // Check feature condition
-        const featureValue = row.features[config.featureName];
-        if (featureValue === null || featureValue === undefined) {
-          continue;
-        }
+        const featureValue = rowFeatures[config.featureName];
+        if (featureValue === null || featureValue === undefined) continue;
 
-        let conditionMet = false;
         if (config.operator === '>') {
-          conditionMet = featureValue > config.value;
+          if (featureValue <= config.value) continue;
         } else if (config.operator === '<') {
-          conditionMet = featureValue < config.value;
-        }
-
-        if (!conditionMet) continue;
-
-        // Get forward return
-        const forwardReturn = row.forwardReturns[`h${config.horizon}`];
-        if (forwardReturn === null) {
+          if (featureValue >= config.value) continue;
+        } else {
           continue;
         }
 
+        // Get forward return (precomputed horizon key)
+        const forwardReturn = rowForwardReturns[config.horizonKey];
+        if (forwardReturn === null) continue;
+
         // Accumulate stats
-        if (!configStats.has(configKey)) {
-          configStats.set(configKey, {
-            config,
-            indices: [],
-            returns: []
-          });
+        if (!stats) {
+          stats = { config, indices: [], returns: [] };
+          configStats.set(configKey, stats);
         }
 
-        const currentStats = configStats.get(configKey);
-
         // Only store if under limit
-        if (currentStats.indices.length < MAX_INDICES_PER_CONFIG) {
-          currentStats.indices.push(rowIndex);
-          currentStats.returns.push(forwardReturn);
+        if (stats.indices.length < MAX_INDICES_PER_CONFIG) {
+          stats.indices.push(rowIndex);
+          stats.returns.push(forwardReturn);
         }
       }
 
@@ -569,6 +659,8 @@ export class PatternScanner {
       }
     }
 
+    log('after_iterate', rowIndex, 'N/A');
+
     // Count how many configs hit the limit
     for (const [key, stats] of configStats) {
       if (stats.indices.length >= MAX_INDICES_PER_CONFIG) {
@@ -621,9 +713,13 @@ export class PatternScanner {
       });
     }
 
+    log('after_build', rowIndex, patterns.length);
+
     const limited = patterns.slice(0, this.maxPatternsPerMethod);
     console.log(`[PatternScanner] Threshold scan found ${patterns.length} patterns (kept ${limited.length})`);
 
+    log('end', rowIndex, patterns.length);
+
     return limited;
   }
 
