   140	      : 0;
   141	
   142	    // 2. Welch's t-test (with streaming non-pattern statistics)
   143	    tests.tTest = this.#welchTTestStreaming(patternReturns, {
   144	      count: nonPatternCount,
   145	      mean: nonPatternMean,
   146	      variance: nonPatternVariance
   147	    });
   148	    tests.tTest.passed = tests.tTest.pValue < this.pValueThreshold;
   149	
   150	    // 3. Permutation test (conditional - feature flag)
   151	    if (this.permutationTestEnabled) {
   152	      // Permutation test requires full non-pattern returns array
   153	      // Re-collect non-pattern returns (memory intensive, but exact)
   154	      const nonPatternReturns = [];
   155	      for (let i = 0; i < dataset.rows.length; i++) {
   156	        const row = dataset.rows[i];
   157	        const forwardReturn = row.forwardReturns[`h${pattern.horizon}`];
   158	        if (forwardReturn === null) continue;
   159	        if (!pattern.matchingIndices.includes(i)) {
   160	          nonPatternReturns.push(forwardReturn);
   161	        }
   162	      }
   163	
   164	      tests.permutationTest = this.#permutationTest(
   165	        patternReturns,
   166	        nonPatternReturns,
   167	        this.permutationN,
   168	        this.seed
   169	      );
   170	      tests.permutationTest.passed = tests.permutationTest.pValue < this.pValueThreshold;
   171	    } else {
   172	      // Permutation test disabled (default)
   173	      tests.permutationTest = {
   174	        pValue: null,
   175	        nPermutations: 0,
   176	        skipped: true,
   177	        passed: true,  // Don't penalize for skipping
   178	        reason: 'Permutation test disabled (set DISCOVERY_PERMUTATION_TEST=true to enable)'
   179	      };
   180	    }
   181	
   182	    // 4. Sharpe ratio test
   183	    const sharpe = this.#calculateSharpe(patternReturns);
   184	    tests.sharpeTest = {
   185	      sharpe,
   186	      minRequired: this.minSharpe,
   187	      passed: sharpe >= this.minSharpe
   188	    };
   189	
   190	    // 5. Regime robustness (if pattern has regime constraints)
   191	    if (pattern.regimes && pattern.regimes.length > 0) {
   192	      tests.regimeRobustness = this.#testRegimeRobustness(pattern, dataset);
   193	    } else {
   194	      tests.regimeRobustness = {
   195	        perRegimeSharpe: {},
   196	        passed: true // No regime constraint = always passes
   197	      };
   198	    }
   199	
   200	    // Calculate overall score
   201	    const scores = [];
   202	    scores.push(tests.tTest.passed ? 1 : 0);
   203	    scores.push(tests.permutationTest.passed ? 1 : 0);
   204	    scores.push(tests.sharpeTest.passed ? 1 : 0);
   205	    scores.push(tests.regimeRobustness.passed ? 1 : 0);
   206	
   207	    const overallScore = scores.reduce((a, b) => a + b, 0) / scores.length;
   208	
   209	    // Determine significance
   210	    const isSignificant = overallScore >= 0.75; // 3/4 tests must pass
   211	
   212	    const recommendation = isSignificant ? 'ACCEPT' :
   213	                          overallScore >= 0.5 ? 'WEAK' :
   214	                          'REJECT';
   215	
   216	    return {
   217	      patternId: pattern.id,
   218	      isSignificant,
   219	      tests,
   220	      overallScore,
   221	      recommendation
   222	    };
   223	  }
   224	
   225	  /**
   226	   * Batch test multiple patterns with multiple comparison correction
   227	   * @param {Array<PatternCandidate>} patterns
   228	   * @param {DiscoveryDataset} dataset
   229	   * @returns {Array<EdgeTestResult>}
   230	   */
   231	  testBatch(patterns, dataset) {
   232	    console.log(`[StatisticalEdgeTester] Testing ${patterns.length} patterns...`);
   233	
   234	    const results = patterns.map(pattern => this.test(pattern, dataset));
   235	
   236	    // Apply Bonferroni correction if enabled
   237	    if (this.multipleComparisonCorrection && patterns.length > 1) {
   238	      const adjustedThreshold = this.pValueThreshold / patterns.length;
   239	
   240	      console.log(`[StatisticalEdgeTester] Applying Bonferroni correction: ${this.pValueThreshold} / ${patterns.length} = ${adjustedThreshold.toFixed(6)}`);
   241	
   242	      results.forEach(result => {
   243	        // Re-evaluate with adjusted threshold
   244	        const tTestPassed = result.tests.tTest.pValue < adjustedThreshold;
   245	
   246	        // Permutation test: only re-evaluate if it was actually run
   247	        let permTestPassed;
   248	        if (result.tests.permutationTest.skipped) {
   249	          permTestPassed = true;  // Don't penalize for skipping
   250	        } else {
   251	          permTestPassed = result.tests.permutationTest.pValue < adjustedThreshold;
   252	        }
   253	
   254	        result.tests.tTest.passed = tTestPassed;
   255	        result.tests.permutationTest.passed = permTestPassed;
   256	
   257	        // Recalculate overall score
   258	        const scores = [
   259	          tTestPassed ? 1 : 0,
   260	          permTestPassed ? 1 : 0,
   261	          result.tests.sharpeTest.passed ? 1 : 0,
   262	          result.tests.regimeRobustness.passed ? 1 : 0
   263	        ];
   264	
   265	        result.overallScore = scores.reduce((a, b) => a + b, 0) / scores.length;
   266	        result.isSignificant = result.overallScore >= 0.75;
   267	        result.recommendation = result.isSignificant ? 'ACCEPT' :
   268	                               result.overallScore >= 0.5 ? 'WEAK' :
   269	                               'REJECT';
   270	      });
   271	    }
   272	
   273	    const accepted = results.filter(r => r.recommendation === 'ACCEPT').length;
   274	    const weak = results.filter(r => r.recommendation === 'WEAK').length;
   275	    const rejected = results.filter(r => r.recommendation === 'REJECT').length;
   276	
   277	    console.log(`[StatisticalEdgeTester] Results: ${accepted} ACCEPT, ${weak} WEAK, ${rejected} REJECT`);
   278	
   279	    return results;
   280	  }
