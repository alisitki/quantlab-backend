     1	/**
     2	 * Test: StatisticalEdgeTester
     3	 */
     4	
     5	import { test } from 'node:test';
     6	import assert from 'node:assert/strict';
     7	import { StatisticalEdgeTester } from '../StatisticalEdgeTester.js';
     8	
     9	test('StatisticalEdgeTester - constructor', () => {
    10	  const tester = new StatisticalEdgeTester();
    11	
    12	  assert.ok(tester.minSampleSize > 0);
    13	  assert.ok(tester.pValueThreshold > 0 && tester.pValueThreshold < 1);
    14	  assert.ok(tester.minSharpe >= 0);
    15	});
    16	
    17	test('StatisticalEdgeTester - test with good edge (synthetic)', () => {
    18	  const tester = new StatisticalEdgeTester({
    19	    minSampleSize: 10,
    20	    pValueThreshold: 0.1, // Relaxed for synthetic test
    21	    minSharpe: 0.1
    22	  });
    23	
    24	  // Create synthetic dataset with known edge
    25	  const dataset = {
    26	    rows: [],
    27	    featureNames: ['micro_reversion'],
    28	    metadata: {}
    29	  };
    30	
    31	  // Pattern: indices 0-49 have positive returns (planted edge)
    32	  const matchingIndices = [];
    33	  for (let i = 0; i < 100; i++) {
    34	    const hasEdge = i < 50;
    35	    const forwardReturn = hasEdge ? 0.002 + Math.random() * 0.001 : -0.0005 + Math.random() * 0.001;
    36	
    37	    if (hasEdge) {
    38	      matchingIndices.push(i);
    39	    }
    40	
    41	    dataset.rows.push({
    42	      features: { micro_reversion: hasEdge ? 0.7 : 0.3 },
    43	      regime: 0,
    44	      forwardReturns: { h10: forwardReturn },
    45	      timestamp: BigInt(i * 1000)
    46	    });
    47	  }
    48	
    49	  const pattern = {
    50	    id: 'test_pattern',
    51	    type: 'threshold',
    52	    conditions: [{ feature: 'micro_reversion', operator: '>', value: 0.5 }],
    53	    regimes: null,
    54	    direction: 'LONG',
    55	    support: matchingIndices.length,
    56	    forwardReturns: {
    57	      mean: 0.0025,
    58	      median: 0.0025,
    59	      std: 0.0005,
    60	      count: matchingIndices.length
    61	    },
    62	    horizon: 10,
    63	    matchingIndices
    64	  };
    65	
    66	  const result = tester.test(pattern, dataset);
    67	
    68	  assert.ok(result, 'Should return result');
    69	  assert.equal(result.patternId, 'test_pattern');
    70	  assert.ok(result.tests.sampleSizeTest.passed, 'Sample size test should pass');
    71	  assert.ok(result.tests.tTest, 'Should have t-test result');
    72	  assert.ok(result.tests.permutationTest, 'Should have permutation test result');
    73	  assert.ok(result.tests.sharpeTest, 'Should have Sharpe test result');
    74	  assert.ok(typeof result.overallScore === 'number', 'Should have overall score');
    75	  assert.ok(['ACCEPT', 'WEAK', 'REJECT'].includes(result.recommendation), 'Should have valid recommendation');
    76	
    77	  // With planted edge, should likely pass
    78	  console.log(`  Result: ${result.recommendation}, score: ${result.overallScore.toFixed(2)}`);
    79	});
    80	
    81	test('StatisticalEdgeTester - test with random noise (should reject)', () => {
    82	  const tester = new StatisticalEdgeTester({
    83	    minSampleSize: 10,
    84	    pValueThreshold: 0.05,
    85	    minSharpe: 0.5
    86	  });
    87	
    88	  // Create synthetic dataset with no edge (pure noise)
    89	  const dataset = {
    90	    rows: [],
    91	    featureNames: ['micro_reversion'],
    92	    metadata: {}
    93	  };
    94	
    95	  const matchingIndices = [];
    96	  for (let i = 0; i < 100; i++) {
    97	    const isMatching = i < 50;
    98	    const forwardReturn = Math.random() * 0.002 - 0.001; // Random [-0.001, 0.001]
    99	
   100	    if (isMatching) {
   101	      matchingIndices.push(i);
   102	    }
   103	
   104	    dataset.rows.push({
   105	      features: { micro_reversion: Math.random() },
   106	      regime: 0,
   107	      forwardReturns: { h10: forwardReturn },
   108	      timestamp: BigInt(i * 1000)
   109	    });
   110	  }
   111	
   112	  const pattern = {
   113	    id: 'noise_pattern',
   114	    type: 'threshold',
   115	    conditions: [{ feature: 'micro_reversion', operator: '>', value: 0.5 }],
   116	    regimes: null,
   117	    direction: 'LONG',
   118	    support: matchingIndices.length,
   119	    forwardReturns: {
   120	      mean: 0.0001,
   121	      median: 0.0,
   122	      std: 0.001,
   123	      count: matchingIndices.length
   124	    },
   125	    horizon: 10,
   126	    matchingIndices
   127	  };
   128	
   129	  const result = tester.test(pattern, dataset);
   130	
   131	  // Random noise should fail Sharpe test
   132	  assert.ok(!result.tests.sharpeTest.passed || result.overallScore < 0.75, 'Random noise should not pass all tests');
   133	  console.log(`  Noise pattern result: ${result.recommendation}, score: ${result.overallScore.toFixed(2)}`);
   134	});
   135	
   136	test('StatisticalEdgeTester - insufficient sample size', () => {
   137	  const tester = new StatisticalEdgeTester({
   138	    minSampleSize: 30
   139	  });
   140	
   141	  const dataset = {
   142	    rows: Array(20).fill(null).map((_, i) => ({
   143	      features: { micro_reversion: 0.5 },
   144	      regime: 0,
   145	      forwardReturns: { h10: 0.001 },
   146	      timestamp: BigInt(i * 1000)
   147	    })),
   148	    featureNames: ['micro_reversion'],
   149	    metadata: {}
   150	  };
   151	
   152	  const pattern = {
   153	    id: 'small_sample',
   154	    type: 'threshold',
   155	    conditions: [],
   156	    regimes: null,
   157	    direction: 'LONG',
   158	    support: 20,
   159	    forwardReturns: { mean: 0.001, median: 0.001, std: 0.0005, count: 20 },
   160	    horizon: 10,
   161	    matchingIndices: Array(20).fill(null).map((_, i) => i)
   162	  };
   163	
   164	  const result = tester.test(pattern, dataset);
   165	
   166	  assert.ok(!result.tests.sampleSizeTest.passed, 'Sample size test should fail');
   167	  assert.equal(result.recommendation, 'REJECT', 'Should reject due to insufficient sample');
   168	});
   169	
   170	test('StatisticalEdgeTester - testBatch with Bonferroni correction', () => {
   171	  const tester = new StatisticalEdgeTester({
   172	    minSampleSize: 10,
   173	    pValueThreshold: 0.05,
   174	    multipleComparisonCorrection: true
   175	  });
   176	
   177	  const dataset = {
   178	    rows: Array(100).fill(null).map((_, i) => ({
   179	      features: { micro_reversion: Math.random() },
   180	      regime: 0,
   181	      forwardReturns: { h10: Math.random() * 0.002 - 0.001 },
   182	      timestamp: BigInt(i * 1000)
   183	    })),
   184	    featureNames: ['micro_reversion'],
   185	    metadata: {}
   186	  };
   187	
   188	  const patterns = [
   189	    {
   190	      id: 'pattern1',
   191	      type: 'threshold',
   192	      conditions: [],
   193	      regimes: null,
   194	      direction: 'LONG',
   195	      support: 50,
   196	      forwardReturns: { mean: 0.001, median: 0.001, std: 0.001, count: 50 },
   197	      horizon: 10,
   198	      matchingIndices: Array(50).fill(null).map((_, i) => i)
   199	    },
   200	    {
   201	      id: 'pattern2',
   202	      type: 'threshold',
   203	      conditions: [],
   204	      regimes: null,
   205	      direction: 'SHORT',
   206	      support: 50,
   207	      forwardReturns: { mean: -0.001, median: -0.001, std: 0.001, count: 50 },
   208	      horizon: 10,
   209	      matchingIndices: Array(50).fill(null).map((_, i) => i + 50)
   210	    }
   211	  ];
   212	
   213	  const results = tester.testBatch(patterns, dataset);
   214	
   215	  assert.equal(results.length, 2, 'Should return 2 results');
   216	  assert.ok(results.every(r => r.recommendation), 'All results should have recommendations');
   217	
   218	  console.log(`  Batch test: ${results.map(r => r.recommendation).join(', ')}`);
   219	});
