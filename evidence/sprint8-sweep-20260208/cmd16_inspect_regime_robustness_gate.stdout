   420	    const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
   421	    const std = Math.sqrt(variance);
   422	
   423	    if (std === 0) return 0;
   424	
   425	    // Annualize assuming ~250 trading days, ~8 hours per day, ~1 event per second
   426	    // Events per year â‰ˆ 250 * 8 * 3600 = 7,200,000
   427	    const eventsPerYear = 7200000;
   428	    const annualizedMean = mean * eventsPerYear;
   429	    const annualizedStd = std * Math.sqrt(eventsPerYear);
   430	
   431	    return annualizedStd === 0 ? 0 : annualizedMean / annualizedStd;
   432	  }
   433	
   434	  /**
   435	   * Test regime robustness - does pattern work in target regimes?
   436	   * @param {PatternCandidate} pattern
   437	   * @param {DiscoveryDataset} dataset
   438	   * @returns {Object}
   439	   */
   440	  #testRegimeRobustness(pattern, dataset) {
   441	    const perRegimeSharpe = {};
   442	
   443	    // Calculate Sharpe per regime
   444	    const uniqueRegimes = [...new Set(dataset.rows.map(r => r.regime))];
   445	
   446	    for (const regime of uniqueRegimes) {
   447	      const regimeReturns = [];
   448	
   449	      for (const idx of pattern.matchingIndices) {
   450	        const row = dataset.rows[idx];
   451	        if (row.regime === regime) {
   452	          const ret = row.forwardReturns[`h${pattern.horizon}`];
   453	          if (ret !== null) {
   454	            regimeReturns.push(ret);
   455	          }
   456	        }
   457	      }
   458	
   459	      if (regimeReturns.length > 0) {
   460	        perRegimeSharpe[regime] = this.#calculateSharpe(regimeReturns);
   461	      }
   462	    }
   463	
   464	    // Check if target regimes have good Sharpe
   465	    let passed = true;
   466	
   467	    for (const targetRegime of pattern.regimes) {
   468	      if (perRegimeSharpe[targetRegime] !== undefined && perRegimeSharpe[targetRegime] < this.minSharpe) {
   469	        passed = false;
   470	        break;
   471	      }
   472	    }
   473	
   474	    return {
   475	      perRegimeSharpe,
   476	      passed
   477	    };
   478	  }
   479	
   480	  // --- Helper functions ---
   481	
   482	  #meanDifference(group1, group2) {
   483	    const mean1 = group1.reduce((a, b) => a + b, 0) / group1.length;
   484	    const mean2 = group2.reduce((a, b) => a + b, 0) / group2.length;
   485	    return mean1 - mean2;
   486	  }
   487	
   488	  /**
   489	   * Approximate p-value from t-distribution
   490	   * Using normal approximation for df > 30
   491	   */
   492	  #tDistributionPValue(t, df) {
   493	    if (df > 30) {
   494	      // Normal approximation
   495	      return 2 * (1 - this.#normalCDF(t));
   496	    }
   497	
   498	    // For small df, use conservative approximation
   499	    const z = t * Math.sqrt(df / (df + 1));
   500	    return 2 * (1 - this.#normalCDF(z));
   501	  }
   502	
   503	  /**
   504	   * Standard normal cumulative distribution function
   505	   */
   506	  #normalCDF(x) {
   507	    const t = 1 / (1 + 0.2316419 * Math.abs(x));
   508	    const d = 0.3989423 * Math.exp(-x * x / 2);
   509	    const p = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
   510	
   511	    return x > 0 ? 1 - p : p;
   512	  }
   513	
   514	  /**
   515	   * Create seeded random number generator (LCG)
   516	   * Same as RegimeCluster implementation
   517	   */
   518	  #createSeededRandom(seed) {
   519	    let state = seed;
   520	    return () => {
